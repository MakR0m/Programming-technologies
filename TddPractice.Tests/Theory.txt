Unit-тест — это автоматизированная проверка одного изолированного элемента программы (чаще всего — метода), чтобы убедиться, что он работает правильно.
Признаки хорошего unit-теста:
	1.Изолированность. Тест не зависит от внешних факторов (БД, Файловой системы, API и т.п.)
	2.Автоматичность. Тест можно запускать без ручных действий
	3.Повторяемость. При одинаковых входных данных - всегда одинаковый результат.
	4.Быстродействие. Должен выполняться как можно быстрее
Структура тест (ААА-подход):
	1.Arrange - подготовка данных
	2.Act - вызов тестируемого метода.
	3.Assert - проверка результата.
Разлчиают два подхода к тестированию:
1. Сначала пишем код, потом тестируем
2. Сначала пишем тест, потом код (TDD)

TDD - это методология, при которой сначала пишется тест, который не проходит, затем пишется код, чтобы он прошел тест, и, наконец, рефакторинг.
Цикл TDD:
	1.Red - написать тест, который не проходит.
	2.Green - написать минимальный код, чтобы тест прошел.
	3.Refactor - улучшить код, не нарушая тест.

TDD применяется где:
1. Критически важна логика, а ошибки дорого обходятся (финансы, медицина, валидация данных, бизнес-правила).
2. В библиотеках и фреймворках, где API должен быть надежным.
3. При работе в командах с высокой инженерной культурой.
4. Когда тесты - часть проектирвоания API (в TDD тест как спецификация)
5. На собеседованиях 

TDD НЕ применяется или применяется редко:
1. В UI/UX-разработке (WPF,MAUI,HTML), особенно, если логика сильно связана с визуалом.
2. В проектах, где важно быстро показать результат.
3. Когда работаешь с легаси кодом - в нем часто невозможно начать с теста.
4. Когда нет времени, знаний или желания - пишут код, потом тестируют "по ходу".

TDD чаще всего применяется точечно: "вот тут сложная логика - лучше через TDD".

Инструменты:
	1. Тестовый фреймворк (xUnit, NUnit, MSTest)
	2. Mocking: Moq - подменяет зависимости.
	3. Тестовый раннер (встроен в VS).

Сколько писать тестов для метода? 
HappyPath (ожидание нормальной работы) - обязателен
Ошибки - хотя бы пограничные и null 
Похожие тесты можно объединить с помощью [Theory] и набора значений например throws  [InlineData(0, 10, "totalAmount")], [InlineData(-100, 10, "totalAmount")], [InlineData(1000, 0, "months")]
[Theory] подходит для валидации разных входных данных.
Лучше использовать, когда тест не зависит от побочных эффектов.
Плохой выбор, если сложная arrange - логика - тогда Fact + отдельные тесты читаются лучше.
Пример:
        [Theory]
        [InlineData(0,10,"totalAmount")]
        [InlineData(-10, 10,"totalAmount")]
        [InlineData(1000, 0, "months")]
        [InlineData(1000, -5, "months")]
        [InlineData(0, 0, "totalAmount")] // ожидается, что первое условие сработает
        public void CalculateInstallment_ThrowException_OnInvalidInput(decimal total, int months, string expectedParam)
        {
            //Arrange
            var calculator = new Calculator();
            //Act
            var exception = Assert.Throws<ArgumentOutOfRangeException>(() => calculator.CalculateInstallment(total, months));
            //Assert
            Assert.Equal(expectedParam, exception.ParamName);
        }

Тестирование классов с зависимостями осуществляется при помощи Moq. Moq - фреймворк, предназначенный для имитации объектов.
Позволяет:
- подменять поведение других сервисов, не реализуя их,
- изолировать тестируемый класс от внешнего окружения (БД, API, логеры и т.п.),
- контролировать поведение и проверять взаимодействие между классами.

Библиотека "Moq" в нугете.



