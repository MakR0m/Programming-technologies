namespace Concurrency
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            Console.WriteLine("Пример работы с потоками:");
            ThreadWork();
            await AsyncWork();
            //_ = Task.Run(async () => await AsyncWork()); // запуск без ожидания, но мейн завершит код до того как прилетит ответ.
            await ParallelWork();
            Console.WriteLine("Вызван последним");
        }

        #region Потоки
        //Поток - наименьшая единица выполнения внутри процесса
        //Поток выполняет инструкции кода независимо от других потоков.
        //Процесс - изолированная среда выполнения (например, запущенное приложение)
        //В консольном приложении основной поток создается методом Main, другие потоки создаются Thread
        //Рекомендуется создавать потоки классом Task.Run(() => Method());

        //| Метод                   | Поток создаётся?        | Использует пул потоков?        | Автоматически запускается?           |
        //| ----------------------- | ----------------------- | ------------------------------ | ------------------------------------ |
        //| `new Thread()`          | Да, всегда              | Нет                            | Да                                   |
        //| `Task.Run()`            | Нет(использует из пула) | Да                             | Да                                   |
        //| `new Task(...).Start()` | Нет(использует из пула) | Да                             | Нет(нужно вручную вызвать `Start()`) |
        //| `RunSynchronously()`    | Нет                     | Нет(использует текущий поток)  | Да                                   |


        //Пул потоков (Thread Pool) - это механизм в .NET, который управляет предварительно созданным набором потоков, готовых выполнять задачи.
        //Вместо создания нового потока каждый раз, система берет поток из пула, выполняет задачу и возвращает поток обратно.
        //Создание и уничтожение потока - дорогостоящая операция. Поток создается с выделением памяти под стек. Создание и завершение требуют обращение к ОС.
        //Пул потоков содержит множество уже созданных потоков, которые повторно используются.

        static void ThreadWork()
        {
            Console.WriteLine($"Это основной поток. {Thread.CurrentThread.ManagedThreadId}");
            new Thread(()=>{Console.WriteLine($"Выполняется в потоке: {Thread.CurrentThread.ManagedThreadId}");}).Start(); //Создали новый поток вручную, не из пула
            Task.Run(() => Console.WriteLine($"Выполняется в потоке: {Thread.CurrentThread.ManagedThreadId}")); // Инициализировали таск и тут же запустили
            Task t = new Task(() => Console.WriteLine($"Выполняется в потоке: {Thread.CurrentThread.ManagedThreadId}")); // Инициализировали таск, но не запустили
            t.Start();
        }

        #endregion
        #region Асинхронность
        //Асинхронность не параллельность
        //Асинхронность - про ожидание (например, ответ от сервера). Параллельность - одновременное выполнение (например, вычислений на нескольких ядрах).
        //Асинхронность позволяет выполнять операции без блокировки основного потока.
        //Полезно при: вводе/выводе: чтение файлов, запросы в сеть, обращение к БД.  
        //Улучшение отзывчивости UI или повышении производительности сервера.
        //async - метод можно вызывать асинхронно
        //await - приостанавливает выполнение метода до завершения задачи, не блокируя поток.
        //Принцип работы await:
        //1. Метод разбивается на несколько частей.
        //2. Управление возвращается вызывающему коду.
        //3. После завершения задачи выполнение продолжается с того места, где стоял await
        static async Task AsyncWork()
        {
            HttpClient client = new HttpClient();
            var result = await client.GetAsync("https://www.google.com");
            Console.WriteLine("Асинхронный вызов код респонса с гугла:");
            Console.WriteLine(result.StatusCode);

            var t1 = Task.Delay(1000); //Делей не использует потоки, а использует таймер.
            var t2 = Task.Delay(2000);

            await Task.WhenAll(t1, t2); // ждать обе
            await Task.WhenAny(t1, t2); // ждать первую завершившуюся
        }

        static async Task ParallelWork()
        {
            var tasks = new List<Task>
                {
                    Task.Run(() => Console.WriteLine("task1")),
                    Task.Run(() => Console.WriteLine("task2"))
                };

            await Task.WhenAll(tasks); //дождались всех
            Console.WriteLine("Все задачи завершены");
        }

        //| Свойство                 | await                                 | .Wait() / .Result                    |
        //| ------------------------ | ------------------------------------- | ------------------------------------ |
        //| Тип ожидания             | **Асинхронное** (не блокирует поток)  | Синхронное (блокирует текущий поток) |
        //| Обработка исключений     | Идёт напрямую(`catch (Exception)`)    | Через `AggregateException`           |
        //| Можно использовать в UI  | Да                                    | Нет, может привести к deadlock       |
        //| Нужен `async`-метод      | Да(`await` можно только в `async`)    | Нет                                  |
        //| Блокирует текущий поток? | Нет                                   | Да                                   |
        //Не смотря на то, что в одном методе, мы не можем продолжить выполнение кода, пока не дождемся await, однако, поток не блокируется и в нем может выполняться другой код другого метода.
        //Мы нажимаем на кнопку отрабатывает команда по нажатию, но если она асинхронная, то можно потыкать другие кнопки и они будут работать в этом же потоке, потому что он не блокирован

        //async void плохо потому что: мы не можем применить await, не может отловить исключения, не можем использовать WhenAll, WhenAny, ContinueWith и т.д.
        //а также  отменить выполнение (CancellationToken).
        #endregion
    }
}
